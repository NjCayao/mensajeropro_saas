const db = require("./database");
const axios = require("axios");

class BotHandler {
  constructor() {
    this.config = null;
    this.conocimientos = [];
    this.conversaciones = new Map();
    this.loadConfig();

    // Recargar configuraci√≥n cada 5 minutos
    setInterval(() => this.loadConfig(), 5 * 60 * 1000);
  }

  async loadConfig() {
    try {
      const [configRows] = await db
        .getPool()
        .execute("SELECT * FROM configuracion_bot WHERE id = 1");

      if (configRows.length > 0) {
        this.config = configRows[0];
        this.config.palabras_activacion = JSON.parse(
          this.config.palabras_activacion || "[]"
        );

        console.log("‚úÖ Configuraci√≥n del bot cargada desde BD");
        console.log("   - Bot activo:", this.config.activo ? "S√ç" : "NO");
        console.log(
          "   - API Key:",
          this.config.openai_api_key ? "Configurada" : "NO CONFIGURADA"
        );
        console.log(
          "   - System prompt:",
          this.config.system_prompt ? "Configurado" : "NO configurado"
        );
        console.log(
          "   - Business info:",
          this.config.business_info ? "Configurada" : "NO configurada"
        );
        console.log(
          "   - Palabras activaci√≥n:",
          this.config.palabras_activacion.length
        );
      } else {
        console.log("‚ùå No se encontr√≥ configuraci√≥n del bot en la BD");
      }

      this.conocimientos = [];
      console.log("‚úÖ Bot configurado sin base de conocimiento adicional");
    } catch (error) {
      console.error("Error cargando configuraci√≥n del bot:", error);
    }
  }

  async shouldRespond(mensaje, numero) {
    console.log("üîç Verificando si el bot debe responder...");

    if (!this.config || !this.config.activo) {
      console.log("‚ùå Bot no est√° activo");
      return false;
    }

    // Verificar estado de escalamiento
    try {
      const [estadoRows] = await db
        .getPool()
        .execute(
          "SELECT estado FROM estados_conversacion WHERE numero_cliente = ?",
          [numero]
        );

      if (estadoRows.length > 0 && estadoRows[0].estado === "escalado_humano") {
        console.log(
          `üìµ Conversaci√≥n escalada a humano para ${numero}, bot no responde`
        );
        return false;
      }
    } catch (error) {
      console.error("Error verificando estado de escalamiento:", error);
    }

    // Verificar horario
    if (!this.isInSchedule()) {
      console.log("üïê Fuera de horario");
      return "fuera_horario";
    }

    // Verificar si es un n√∫mero registrado
    const [contactoRows] = await db
      .getPool()
      .execute("SELECT id FROM contactos WHERE numero = ?", [
        numero.replace("@c.us", ""),
      ]);

    const esRegistrado = contactoRows.length > 0;
    console.log(`üì± N√∫mero ${esRegistrado ? "S√ç" : "NO"} est√° registrado`);

    if (!esRegistrado && !this.config.responder_no_registrados) {
      console.log("‚ùå No responder a no registrados");
      return false;
    }

    // Verificar palabras de activaci√≥n
    if (
      this.config.palabras_activacion &&
      this.config.palabras_activacion.length > 0
    ) {
      const mensajeLower = mensaje.toLowerCase();
      const coincide = this.config.palabras_activacion.some((palabra) =>
        mensajeLower.includes(palabra.toLowerCase())
      );

      if (!coincide) {
        console.log("‚ùå No coincide con palabras de activaci√≥n");
        return false;
      }
    }

    console.log("‚úÖ Bot S√ç debe responder");
    return true;
  }

  isInSchedule() {
    if (!this.config.horario_inicio || !this.config.horario_fin) {
      return true;
    }

    const ahora = new Date();
    const horaActual = ahora.getHours() * 60 + ahora.getMinutes();

    const [horaInicio, minInicio] = this.config.horario_inicio
      .split(":")
      .map(Number);
    const [horaFin, minFin] = this.config.horario_fin.split(":").map(Number);

    const inicioMinutos = horaInicio * 60 + minInicio;
    const finMinutos = horaFin * 60 + minFin;

    if (finMinutos >= inicioMinutos) {
      return horaActual >= inicioMinutos && horaActual <= finMinutos;
    } else {
      return horaActual >= inicioMinutos || horaActual <= finMinutos;
    }
  }

  async processMessage(mensaje, numero) {
    try {
      console.log("üìù [processMessage] Iniciando procesamiento");
      const shouldRespond = await this.shouldRespond(mensaje, numero);

      console.log(
        "üìù [processMessage] shouldRespond resultado:",
        shouldRespond
      );

      if (!shouldRespond) {
        console.log("üìù [processMessage] Bot no debe responder, terminando");
        return null;
      }

      if (shouldRespond === "fuera_horario") {
        console.log("üìù [processMessage] Fuera de horario");
        return {
          respuesta:
            this.config.mensaje_fuera_horario ||
            "Gracias por tu mensaje. Nuestro horario de atenci√≥n ha finalizado. Te responderemos lo antes posible.",
          tipo: "fuera_horario",
        };
      }

      // Detectar si necesita escalamiento
      const necesitaEscalamiento = await this.checkEscalamiento(mensaje);

      if (necesitaEscalamiento) {
        console.log("üö® ESCALAMIENTO DETECTADO - Marcando conversaci√≥n");

        try {
          await db.getPool().execute(
            `INSERT INTO estados_conversacion (numero_cliente, estado, fecha_escalado, motivo_escalado) 
             VALUES (?, 'escalado_humano', NOW(), ?)
             ON DUPLICATE KEY UPDATE 
                estado = 'escalado_humano', 
                fecha_escalado = NOW(),
                motivo_escalado = ?`,
            [numero, mensaje, mensaje]
          );

          console.log(`‚úÖ Conversaci√≥n marcada como escalada en BD`);
        } catch (error) {
          console.error("‚ùå Error marcando escalamiento:", error);
        }

        // AQU√ç LEE EL MENSAJE DE ESCALAMIENTO DESDE LA BD
        const mensajeEscalamiento =
          this.config.mensaje_escalamiento ||
          "Tu consulta requiere atenci√≥n personalizada. Un asesor humano te atender√° en breve.";

        return {
          respuesta: mensajeEscalamiento,
          tipo: "escalamiento",
        };
      }

      console.log(
        "üìù [processMessage] Aplicando delay de",
        this.config.delay_respuesta,
        "segundos"
      );

      await new Promise((resolve) =>
        setTimeout(resolve, this.config.delay_respuesta * 1000)
      );

      console.log("üìù [processMessage] Obteniendo contexto");
      const contexto = await this.getContexto(numero);

      console.log("üìù [processMessage] Generando respuesta con IA");
      const respuestaIA = await this.generateResponse(mensaje, contexto);

      console.log("üìù [processMessage] Guardando conversaci√≥n");
      await this.saveConversation(numero, mensaje, respuestaIA);

      console.log(
        "üìù [processMessage] Respuesta lista:",
        respuestaIA.content.substring(0, 50) + "..."
      );
      return {
        respuesta: respuestaIA.content,
        tipo: "bot",
        tokens: respuestaIA.tokens,
        tiempo: respuestaIA.tiempo,
      };
    } catch (error) {
      console.error(
        "‚ùå [processMessage] Error procesando mensaje:",
        error.message
      );
      console.error("Stack trace:", error.stack);

      let mensajeError =
        "Lo siento, tuve un problema al procesar tu mensaje üòÖ";

      if (error.message.includes("API Key")) {
        mensajeError =
          "Ups! Parece que hay un problema con la configuraci√≥n üîß Por favor contacta al administrador.";
      } else if (error.message.includes("cr√©ditos")) {
        mensajeError =
          "Oh no! Parece que se agotaron los cr√©ditos de IA üí∏ Por favor contacta al administrador.";
      } else if (error.message.includes("rate")) {
        mensajeError =
          "Estoy recibiendo muchos mensajes ahora mismo üòµ Dame unos segundos y vuelve a intentar.";
      }

      return {
        respuesta: mensajeError,
        tipo: "error",
      };
    }
  }

  async checkEscalamiento(mensaje) {
    // AQU√ç DEBER√çAMOS LEER LAS FRASES DE ESCALAMIENTO DESDE LA BD
    // Por ahora uso un campo JSON en la configuraci√≥n
    let frasesEscalamiento = [];

    try {
      if (this.config.frases_escalamiento) {
        frasesEscalamiento = JSON.parse(this.config.frases_escalamiento);
      }
    } catch (e) {
      // Si no es JSON v√°lido, intentar split por comas
      if (this.config.frases_escalamiento) {
        frasesEscalamiento = this.config.frases_escalamiento
          .split(",")
          .map((f) => f.trim())
          .filter((f) => f.length > 0);
      }
    }

    // Si no hay frases configuradas, no escalar
    if (frasesEscalamiento.length === 0) {
      return false;
    }

    const mensajeLower = mensaje.toLowerCase();

    const necesitaEscalar = frasesEscalamiento.some((frase) => {
      const contieneFrase = mensajeLower.includes(frase.toLowerCase());
      if (contieneFrase) {
        console.log(`üîç Frase de escalamiento detectada: "${frase}"`);
      }
      return contieneFrase;
    });

    console.log(
      `üìã Resultado verificaci√≥n escalamiento: ${
        necesitaEscalar ? "S√ç ESCALAR" : "NO ESCALAR"
      }`
    );

    return necesitaEscalar;
  }

  async getContexto(numero) {
    const [rows] = await db.getPool().execute(
      `SELECT mensaje_cliente, respuesta_bot, fecha_hora 
       FROM conversaciones_bot 
       WHERE numero_cliente = ? 
       ORDER BY fecha_hora DESC 
       LIMIT 5`,
      [numero]
    );

    return rows.reverse();
  }

  async generateResponse(mensaje, contexto) {
    const inicio = Date.now();

    // VERIFICAR configuraci√≥n m√≠nima
    if (!this.config.system_prompt || !this.config.openai_api_key) {
      throw new Error("Bot no configurado correctamente");
    }

    // TODO viene de la BD
    let systemPrompt = this.config.system_prompt;

    // Agregar informaci√≥n del negocio si existe
    if (this.config.business_info) {
      systemPrompt += `\n\nINFORMACI√ìN DEL NEGOCIO:\n${this.config.business_info}`;
    }

    // Construir mensajes con contexto
    const messages = [{ role: "system", content: systemPrompt }];

    // Agregar contexto de conversaci√≥n
    contexto.forEach((conv) => {
      messages.push({ role: "user", content: conv.mensaje_cliente });
      if (conv.respuesta_bot) {
        messages.push({ role: "assistant", content: conv.respuesta_bot });
      }
    });

    // Agregar mensaje actual
    messages.push({ role: "user", content: mensaje });

    try {
      const response = await axios.post(
        "https://api.openai.com/v1/chat/completions",
        {
          model: this.config.modelo_ai || "gpt-3.5-turbo",
          messages: messages,
          temperature: parseFloat(this.config.temperatura) || 0.7,
          max_tokens: parseInt(this.config.max_tokens) || 150,
        },
        {
          headers: {
            Authorization: `Bearer ${this.config.openai_api_key}`,
            "Content-Type": "application/json",
          },
          timeout: 30000,
        }
      );

      const tiempo = Date.now() - inicio;

      return {
        content: response.data.choices[0].message.content,
        tokens: response.data.usage.total_tokens,
        tiempo: tiempo,
      };
    } catch (error) {
      console.error("‚ùå Error llamando a OpenAI:");

      if (error.response) {
        console.error("Status:", error.response.status);
        console.error("Data:", JSON.stringify(error.response.data, null, 2));

        if (error.response.status === 401) {
          throw new Error("API Key inv√°lida o sin permisos");
        } else if (error.response.status === 429) {
          throw new Error("L√≠mite de rate excedido o sin cr√©ditos");
        } else if (error.response.status === 400) {
          const mensaje =
            error.response.data?.error?.message || "Error en la petici√≥n";
          throw new Error(`OpenAI error: ${mensaje}`);
        }
      } else {
        console.error("Error de red:", error.message);
      }

      throw error;
    }
  }

  async saveConversation(numero, mensajeCliente, respuestaIA) {
    try {
      const contactoId = await this.getContactoId(numero);

      await db.getPool().execute(
        `INSERT INTO conversaciones_bot 
         (numero_cliente, mensaje_cliente, respuesta_bot, contexto_conversacion,
          es_cliente_registrado, tokens_usados, tiempo_respuesta)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [
          numero,
          mensajeCliente,
          respuestaIA.content,
          JSON.stringify(await this.getContexto(numero)),
          contactoId !== null,
          respuestaIA.tokens || 0,
          respuestaIA.tiempo || 0,
        ]
      );

      this.cleanConversationCache();
    } catch (error) {
      console.error("Error guardando conversaci√≥n:", error);
    }
  }

  async getContactoId(numero) {
    const [rows] = await db
      .getPool()
      .execute("SELECT id FROM contactos WHERE numero = ?", [
        numero.replace("@c.us", ""),
      ]);

    return rows.length > 0 ? rows[0].id : null;
  }

  cleanConversationCache() {
    if (this.conversaciones.size > 100) {
      const entries = Array.from(this.conversaciones.entries());
      const toDelete = entries.slice(0, entries.length - 100);
      toDelete.forEach(([key]) => this.conversaciones.delete(key));
    }
  }

  // M√©todo para manejar mensajes entrantes
  async handleIncomingMessage(from, body, isGroup = false) {
    const numero = from;
    const mensaje = body || "";

    console.log(`ü§ñ Bot evaluando mensaje de ${numero}: "${mensaje}"`);

    if (!mensaje || mensaje.trim() === "") {
      console.log("ü§ñ Mensaje vac√≠o, ignorando");
      return null;
    }

    const respuesta = await this.processMessage(mensaje, numero);

    if (respuesta) {
      console.log(
        `ü§ñ Bot respondiendo con: "${respuesta.respuesta.substring(0, 50)}..."`
      );
      return respuesta;
    }

    return null;
  }
  
}

module.exports = BotHandler;
